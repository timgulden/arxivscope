# Enrichment System Integration Guide

## Overview

The DocTrove system has **two separate enrichment processes** that work independently and do not interfere with each other:

1. **1D Embedding Generation** (`embedding_service.py`) - Generates 1D embeddings from text
2. **2D Embedding Generation** (`functional_embedding_2d_enrichment.py`) - Converts 1D to 2D embeddings

## System Architecture

### 1D Embedding Process (Primary)
- **File**: `embedding_service.py`
- **Purpose**: Generates 1D embeddings from paper titles and abstracts
- **Target Column**: `doctrove_embedding` (1D vector)
- **Event Listener**: `event_listener_functional.py` (handles 1D embeddings)
- **Process**: Text → Azure OpenAI → 1D embedding vector

### 2D Embedding Process (Secondary)
- **File**: `functional_2d_processor.py` (CURRENTLY ACTIVE)
- **Purpose**: Converts 1D embeddings to 2D for visualization
- **Target Column**: `doctrove_embedding_2d` (PostgreSQL point)
- **Event Listener**: `event_listener_2d.py` (IN DEVELOPMENT - not currently working)
- **Process**: 1D embedding → UMAP → 2D coordinates
- **Status**: ✅ **ACTIVE** - Processing at ~8.2 papers/second

## Database Schema

```sql
-- Main papers table
CREATE TABLE doctrove_papers (
    doctrove_paper_id UUID PRIMARY KEY,
    doctrove_title TEXT,
    doctrove_abstract TEXT,
    doctrove_embedding TEXT[],           -- 1D embeddings (generated by embedding_service.py)
    doctrove_embedding_2d POINT,         -- 2D embeddings (generated by functional_embedding_2d_enrichment.py)
    -- ... other columns
);
```

## Process Flow

### 1D Embedding Flow
```
New Paper → event_listener_functional.py → embedding_service.py → doctrove_embedding
```

### 2D Embedding Flow (CURRENT)
```
Paper with 1D embedding → functional_2d_processor.py → doctrove_embedding_2d
```

### 2D Embedding Flow (FUTURE - Event Listener)
```
Paper with 1D embedding → event_listener_2d.py → functional_embedding_2d_enrichment.py → doctrove_embedding_2d
```

## Startup Configuration

### With `--with-enrichment` Flag
When you run `./startup.sh --with-enrichment --background`, the system starts:

1. **API Server** (doctrove-api)
2. **Frontend** (docscope)
3. **1D Event Listener** (`event_listener_functional.py`) - Handles 1D embeddings
4. **2D Event Listener** (`event_listener_2d.py`) - Handles 2D embeddings

### Independent Operation
- **1D Process**: Continuously processes papers that need 1D embeddings
- **2D Process**: Continuously processes papers that have 1D embeddings but need 2D embeddings
- **No Interference**: Each process works on different columns and conditions

## Query Conditions

### 1D Embedding Query
```sql
SELECT * FROM doctrove_papers 
WHERE doctrove_embedding IS NULL
AND doctrove_title IS NOT NULL
AND doctrove_title != ''
```

### 2D Embedding Query
```sql
SELECT * FROM doctrove_papers 
WHERE doctrove_embedding_2d IS NULL
AND doctrove_embedding IS NOT NULL
AND doctrove_title IS NOT NULL
AND doctrove_title != ''
```

## Log Files

- **1D Process**: `enrichment_1d.log` (from `event_listener_functional.py`)
- **2D Process**: `enrichment_2d.log` (from `event_listener_2d.py`)

## Functional Programming Benefits

### 1D Process (Existing)
- Uses `embedding_service.py` with batch processing
- Handles Azure OpenAI API calls
- Manages rate limiting and retries

### 2D Process (New Functional)
- Uses pure functional programming principles
- Immutable data structures with `NamedTuple`
- Functional composition with `map`, `filter`, `reduce`
- No classes, only pure functions
- Pre-loaded UMAP model for efficiency

## Monitoring

### Check 1D Process
```bash
# Check 1D embedding status
python embedding_service.py --status

# Monitor 1D process logs
tail -f enrichment_1d.log
```

### Check 2D Process
```bash
# Check 2D embedding status
python test_functional_enrichment.py

# Monitor 2D process logs
tail -f enrichment_2d.log
```

### Check Both Processes
```bash
# Check overall enrichment status
python check_embedding_status.py
```

## Troubleshooting

### If 1D Process Stops
- Check `enrichment_1d.log` for errors
- Verify Azure OpenAI API access
- Restart with: `./startup.sh --with-enrichment --background --restart`

### If 2D Process Stops
- Check `enrichment_2d.log` for errors
- Verify UMAP model exists (`umap_model.pkl`)
- Check database connectivity
- Restart with: `./startup.sh --with-enrichment --background --restart`

### If Both Processes Stop
- Check system resources
- Verify database connectivity
- Check all log files
- Full restart: `./startup.sh --with-enrichment --background --force`

## Performance Considerations

### 1D Process
- Batch size: 250-500 papers per API call
- Rate limited by Azure OpenAI
- CPU intensive for text processing

### 2D Process
- Batch size: 100 papers per UMAP transform
- Memory intensive for UMAP processing
- GPU acceleration possible for UMAP

## Integration Points

### Database Triggers
- `trigger_queue_2d_embeddings` - Automatically queues papers for 2D processing when they get 1D embeddings
- `papers_needing_2d_embeddings` - Queue table for 2D processing

### Event Listeners
- Both run independently in separate threads
- No shared state or dependencies
- Can be started/stopped independently

## Future Enhancements

### Potential Improvements
1. **Unified Monitoring**: Single dashboard for both processes
2. **Coordinated Batching**: Optimize batch sizes based on system load
3. **Shared Configuration**: Common configuration file for both processes
4. **Health Checks**: Automated health monitoring for both processes

### Scalability
- **Horizontal Scaling**: Multiple instances of each process
- **Load Balancing**: Distribute work across multiple workers
- **Queue Management**: Redis-based queue for better performance

## Conclusion

The enrichment system is designed with **separation of concerns**:

✅ **1D Process**: Handles text-to-embedding generation  
✅ **2D Process**: Handles embedding-to-visualization conversion  
✅ **No Interference**: Each process works independently  
✅ **Functional Programming**: 2D process uses pure functional approach  
✅ **Automatic Startup**: Both start with `--with-enrichment` flag  

This architecture ensures that the 1D embedding process (the primary data generation) is never interrupted by the 2D visualization process, while both benefit from the functional programming approach for maintainability and performance.
